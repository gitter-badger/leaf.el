#+author: conao
#+date: <2018-10-25 Thu>

* leaf.el
[[https://github.com/conao3/leaf.el][https://img.shields.io/github/tag/conao3/leaf.el.svg?style=flat-square]]
[[https://travis-ci.org/conao3/leaf.el][https://img.shields.io/travis/conao3/leaf.el/master.svg?style=flat-square]]
[[https://github.com/conao3/leaf.el][https://img.shields.io/github/license/conao3/leaf.el.svg?style=flat-square]]

- [[#F3A263DD-5AAD-472F-A0C0-1EA786592414][What is it?]]
- [[#59115AE6-787A-4CD4-8406-F54CA6CF88FA][How to use?]]
- [[#658565D4-1F5B-499B-A75F-A320D55BB512][Syntaxes]]
  - [[#D882B509-5F21-4256-A7F8-9A59464689BE][Basic keywords]]
    - [[#0FB96CC0-6010-4F06-8395-06E8DD28CDB0][none (keyword)]]
    - [[#24ECA818-0278-448E-BA2C-92CEC7E00DF7][:require keyword]]
    - [[#E1C4AE04-D595-4D8B-BB9E-93E8C4F5FFC5][:ensure keyword]]
    - [[#2E91C76F-BDB1-49EF-A26F-E5C8715000F6][:defaults keyword]]
  - [[#3B8EDE06-B263-4A08-AB4E-B5305417471A][Configuration keywords]]
    - [[#3362981E-CF81-465A-953E-606FC067941A][:init keyword]]
    - [[#753E1D75-CC46-4428-9961-7BCE3DD5BDA3][:commands keyward]]
    - [[#4D639993-2FC7-4AB7-9834-15E5BAAA5E56][:hook keyword]]
    - [[#E74DF3E7-A8C3-4BB2-9BC5-F3C77BD32378][:mode, :interpreter keyword]]
    - [[#92056B6B-D504-4759-9399-C417E3DA5BA7][:magic, :magic-fallback keyword]]
    - [[#D52D5002-2550-4AB2-9198-27464447BB4C][:bind, :bind* keyword]]
    - [[#D5298BD4-6724-4D3A-932F-50A845F51D96][:pre-setq, :setq keyword]]
    - [[#5C7F02BB-1CBF-48A9-916D-9792A2C3815F][:setq-default, :custom keyword]]
    - [[#F77582D3-F6D8-43E9-98D2-748227AC19B1][:custom-face keyword]]
    - [[#5EF5D2A6-FDA6-4A57-873D-1E2A63EFD0BC][:load-path keyword]]
    - [[#390B5A74-6FD1-45AF-809B-AF8ACD35D40D][:config keyword]]
  - [[#601B40F8-E41C-4DF2-94E0-22059D2F0AEE][Condition keywords]]
    - [[#FB78E91B-A83E-4435-98A5-06A88BD2B58D][:disabled keyword]]
    - [[#19A9FBE7-3F00-4CDF-A3DA-73B7140EC566][:if, :when, :unless keyword]]
  - [[#FCA0C2E6-21C6-475C-AEA7-272649A21CE0][Byte compile keywords]]
    - [[#2889E811-A291-47F7-B714-FABE4034D240][:byte-compile-funcs, :byte-compile-vars keyword]]
  - [[#AEB3D9C7-C27A-4C0D-B7CA-8E3929A18C46][Documentation keywords]]
- [[#091E1E16-C805-4EFC-B3DF-8CFFEF262016][Developer information]]
  - [[#ECE81F64-86A4-41E2-921B-7BC8C0088C04][leaf.el mechanism]]
    - [[#BC5DC943-58E0-40DC-9CF5-43521E990E7C][leaf (name &rest args) macro]]
    - [[#95158ACD-2622-4DC4-804D-366CC1DE240C][leaf-core (name args) function]]
      - [[#6A42C4A3-DD34-45A8-9D6D-D51985000CAC][leaf-append-defaults (plist) function]]
      - [[#ADCDCD51-44E1-4D1B-AE7F-EA04743EFD25][leaf-normalize-plist (plsit mergep) function]]
      - [[#A875F061-194B-4CAC-B124-923533DC6529][leaf-sort-values-plist (plist) function]]
    - [[#F4C1ECC9-1004-471F-8C82-BB33A21A0863][leaf-pcocess-keywords (name plist) function]]
  - [[#7CFD0D29-9E59-4726-B8BC-17A8042075BC][Adding custom keyword(s)]]
    - [[#1C8BA8F9-AF24-490B-9E36-8D0985014D12][Add keyword(s)]]
    - [[#F2358E14-FC68-4E06-9B19-781C0A8B7766][Define handler]]
- [[#773EEC5D-AE59-4BD9-ABC9-BE3540BAD0DC][Why We support Emacs-22?]]
- [[#472A6387-7B54-4ED4-8C39-21E291C7D990][Welcome PR]]
- [[#16502214-F943-4A31-ABB4-217AC14FCE53][Special Thanks]]

* What is it?
:PROPERTIES:
:ID:       F3A263DD-5AAD-472F-A0C0-1EA786592414
:END:
~leaf.el~ is yet another [[https://github.com/jwiegley/use-package][use-package]].

~leaf.el~ has strong conditional branching symbols, 
making your Emacs configuration simpler.

It operates from Emacs-22, obtains partner [[https://github.com/conao3/feather.el][feather]] and realizes Emacs packages and configurations which can be regenerated. 

You do not have to worry about errors due to reinstallation or environmental differences.

* How to use?
:PROPERTIES:
:ID:       59115AE6-787A-4CD4-8406-F54CA6CF88FA
:END:
Put ~leaf.el~ at any folder added ~load-path~.
Then ~(require 'leaf)~ and use like ~use-pacakge~

#+BEGIN_SRC emacs-lisp
  ;; add to load-path
  ;; (locate-user-emacs-file "site-lisp/leaf.el")
  ;;  => "~/.emacs.d/local/26.1/site-lisp/leaf.el"

  (add-to-list 'load-path (locate-user-emacs-file "site-lisp/leaf.el"))
  (add-to-list 'load-path (locate-user-emacs-file "site-lisp/feather.el"))

  (require 'leaf)

  (leaf package
    :config
    (add-list-to-list 'package-archives
      '(("org"       . "https://orgmode.org/elpa/")
        ("melpa"     . "https://melpa.org/packages/")
        ("marmalade" . "https://marmalade-repo.org/packages/")))
    (package-initialize))

  (leaf bind-key :ensure t)
#+END_SRC
* Syntaxes
:PROPERTIES:
:ID:       658565D4-1F5B-499B-A75F-A320D55BB512
:END:
All below examples are excerpts from ~leaf-tests.el~.

These examples are defined in the following format.
We expect FORM will be expanded to EXPECT.
#+begin_src emacs-lisp
  (cort-deftest TESTCASE-NAME
    (match-expansion
     FORM                  ; will be expand by `macroexpand-1'
     'EXPECT))             ; expect FORM's expansion will be EXPECT (test by `equal')

  (cort-deftest TESTCASE-NAME
    (match-expansion-let (LET-ENV)
      FORM                 ; will be expanded by `macroexpand-1' in LET-ENV
      'EXPECT))            ; expect FORM's expansion will be EXPECT (test by `equal')

  ;; test functions, macros return boolean value
  (defun rt () t)
  (defun rnil () nil)
  (defmacro mt () `(rt))
  (defmacro mnil () `(rnil))
#+end_src

** Basic keywords
:PROPERTIES:
:ID:       D882B509-5F21-4256-A7F8-9A59464689BE
:END:
*** none (keyword)
:PROPERTIES:
:ID:       0FB96CC0-6010-4F06-8395-06E8DD28CDB0
:END:
If ~leaf~ use without specifying any symbol, it simply works as a substitute for ~require~.
#+begin_src emacs-lisp
  (cort-deftest leaf-test:/simple-none
    (match-expansion
     (leaf foo)
     '(progn
        (require 'foo))))
#+end_src

*** :require keyword
:PROPERTIES:
:ID:       24ECA818-0278-448E-BA2C-92CEC7E00DF7
:END:
~leaf~ interprets that it is given default by ~:require t~.

~leaf~ do not ~require~ anything when ~nil~ is given, 
and if give multiple values it ~require~ each package.

#+begin_src emacs-lisp
  (cort-deftest leaf-test/:simple-require
    (match-expansion
     (leaf foo
           :require t     ; not necessary to declare this specifically (default)
           :config (setq bar 'baz))
     '(progn
        (require 'foo)
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-require-nil
    (match-expansion
     (leaf foo
           :require nil
           :config (setq bar 'baz))
     '(progn
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-multi-require
    (match-expansion
     (leaf foo
           :require foo-hoge foo-piyo
           :config (setq bar 'baz))
     '(progn
        (require foo-hoge)
        (require foo-piyo)
        (setq bar 'baz))))
#+end_src

*** :ensure keyword
:PROPERTIES:
:ID:       E1C4AE04-D595-4D8B-BB9E-93E8C4F5FFC5
:END:
~:ensure~ provide package download, compile frontend for 
package manager for example, ~feather.el~ and ~package.el~ etc...

You can customize backend to process ~:ensure~ keyword.
#+BEGIN_SRC emacs-lisp
  ;; use package.el as :ensure backend
  (setq leaf-backend/:ensure 'package)

  ;; use feather.el as :ensure backend
  (setq leaf-backend/:ensure 'feather)

  ;; use no package as :ensure backend (disable :ensure)
  (setq leaf-backend/:ensure nil)
#+END_SRC

~leaf.el~ provide ~feather.el~ and ~package.el~ backend,
but it's easy to create other package manager's backend.

Of course, setting and requiring of the backend itself must be
completed before using ~:ensure~ keyword.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-ensure
    (match-expansion-let ((leaf-backend/:ensure 'package))
     (leaf foo :ensure t)
     '(progn
        (funcall #'leaf-backend/:ensure-package 'foo 'foo)
        (progn
          (require 'foo)))))
#+END_SRC
*** :defaults keyword
:PROPERTIES:
:ID:       2E91C76F-BDB1-49EF-A26F-E5C8715000F6
:END:
~:defalts~ provide to download default settings for specified package.
For more detail, see [[https://github.com/conao3/leaf-defaults.git][leaf-defaults]].
#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-defaults
    (match-expansion-let ((leaf-backend/:ensure 'package))
     (leaf foo :ensure t :defaults t)
     '(progn
        (funcall #'leaf-backend/:ensure-package 'foo 'foo)
        (feather-install-defaults 'foo)
        (progn
          (require 'foo)))))
#+END_SRC
** Configuration keywords
:PROPERTIES:
:ID:       3B8EDE06-B263-4A08-AB4E-B5305417471A
:END:
*** :init keyword
:PROPERTIES:
:ID:       3362981E-CF81-465A-953E-606FC067941A
:END:
~:init~ keyword expect sexp will be evaluated before ~require~ package.

#+begin_src emacs-lisp
  (cort-deftest leaf-test/:simple-init
    (match-expansion
     (leaf foo
           :init
           (setq bar1 'baz)
           (setq bar2 'baz))
     '(progn
        (progn
          (setq bar1 'baz)
          (setq bar2 'baz))
        (progn
          (require 'foo)))))
#+end_src

*** :commands keyward
:PROPERTIES:
:ID:       753E1D75-CC46-4428-9961-7BCE3DD5BDA3
:END:
~:commands~ keyword define additional autoload commands.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-commands
    (match-expansion
     (leaf ace-jump-mode
       :commands ace-jump-mode)
     '(progn
        (add-hook #'ace-jump-mode "ace-jump-mode" nil t)
        (require 'ace-jump-mode))))

  (cort-deftest leaf-test/:simple-multi-commands
    (match-expansion
     (leaf ace-jump-mode
       :commands ace-jump-mode command1 command2)
     '(progn
        (add-hook #'ace-jump-mode "ace-jump-mode" nil t)
        (add-hook #'command1 "ace-jump-mode" nil t)
        (add-hook #'command2 "ace-jump-mode" nil t)
        (require 'ace-jump-mode))))
#+END_SRC

*** :hook keyword
:PROPERTIES:
:ID:       4D639993-2FC7-4AB7-9834-15E5BAAA5E56
:END:
~:hook~ keyword define ~add-hook~.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-hook
    (match-expansion
     (leaf ace-jump-mode
       :hook cc-mode-hook)
     '(progn
    (autoload #'ace-jump-mode "ace-jump-mode" nil t)
    (add-hook 'cc-mode-hook #'ace-jump-mode)
    (require 'ace-jump-mode))))

  (cort-deftest leaf-test/:simple-multi-hook
    (match-expansion
     (leaf ace-jump-mode
       :hook cc-mode-hook (prog-mode-hook . ace-jump-mode))
     '(progn
        (autoload #'ace-jump-mode "ace-jump-mode" nil t)
        (add-hook 'cc-mode-hook #'ace-jump-mode)
        (add-hook 'prog-mode-hook #'ace-jump-mode)
        (require 'ace-jump-mode))))
#+END_SRC
*** :mode, :interpreter keyword
:PROPERTIES:
:ID:       E74DF3E7-A8C3-4BB2-9BC5-F3C77BD32378
:END:
~:mode~ keyword define ~auto-mode-alist~. When open file, enable major-mode.
~:interpreter~ keyword define ~interpreter-mode-alist~. enable major-mode by shebang.

If you pass symbol to these keyword, adopd package name.
If you want to specify major-mode, pass dotted pair value.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-mode
    (match-expansion
     (leaf ruby-mode
       :mode "\\.rb\\'"
       :interpreter "ruby")
     '(progn
        (autoload #'ruby-mode "ruby-mode" nil t)
        (leaf-list-add-to-list 'auto-mode-alist
                               '(("\\.rb\\'" . ruby-mode)))
        (autoload #'ruby-mode "ruby-mode" nil t)
        (leaf-list-add-to-list 'interpreter-mode-alist
                               '(("ruby" . ruby-mode)))
        (require 'ruby-mode))))

  (cort-deftest leaf-test/:simple-multi-mode
    (match-expansion
     (leaf ruby-mode
       :mode "\\.rb\\'" "\\.rb2\\'" ("\\.rbg\\'" . rb-mode)
       :interpreter "ruby")
     '(progn
        (autoload #'ruby-mode "ruby-mode" nil t)
        (autoload #'rb-mode "ruby-mode" nil t)
        (leaf-list-add-to-list 'auto-mode-alist
                               '(("\\.rb\\'" . ruby-mode)
                                 ("\\.rb2\\'" . ruby-mode)
                                 ("\\.rbg\\'" . rb-mode)))
        (autoload #'ruby-mode "ruby-mode" nil t)
        (leaf-list-add-to-list 'interpreter-mode-alist
                               '(("ruby" . ruby-mode)))
        (require 'ruby-mode))))
#+END_SRC

*** :magic, :magic-fallback keyword
:PROPERTIES:
:ID:       92056B6B-D504-4759-9399-C417E3DA5BA7
:END:
~:magic~ keyword define ~magic-mode-alist~. It is used to determine major-mode by
binary header byte.
~:magic-fallback~  keyward also define ~magic-fallback-alist~

#+BEGIN_SRC emacs-lisp
(cort-deftest leaf-test/:simple-magic
  (match-expansion
   (leaf pdf-tools
     :magic ("%PDF" . pdf-view-mode)
     :config
     (pdf-tools-install))
   '(progn
      (autoload #'pdf-tools "pdf-tools" nil t)
      (autoload #'pdf-view-mode "pdf-tools" nil t)
      (leaf-list-add-to-list 'magic-mode-alist
                             '(("%PDF" . pdf-view-mode)))
      (require 'pdf-tools)
      (pdf-tools-install))))

(cort-deftest leaf-test/:simple-magic-fallback
  (match-expansion
   (leaf pdf-tools
     :magic-fallback ("%PDF" . pdf-view-mode)
     :config
     (pdf-tools-install))
   '(progn
      (autoload #'pdf-tools "pdf-tools" nil t)
      (autoload #'pdf-view-mode "pdf-tools" nil t)
      (leaf-list-add-to-list 'magic-fallback-mode-alist
                             '(("%PDF" . pdf-view-mode)))
      (require 'pdf-tools)
      (pdf-tools-install))))
#+END_SRC
*** :bind, :bind* keyword
:PROPERTIES:
:ID:       D52D5002-2550-4AB2-9198-27464447BB4C
:END:
~:bind~ provide ~bind-key.el~ frontend.

You can customize backend to process ~:ensure~ keyword.
#+BEGIN_SRC emacs-lisp
  ;; use package.el as :bind backend
  (setq leaf-backend/:bind  'bind-key
        leaf-backend/:bind* 'bind-key)

  ;; use no package as :bind backend (disable :bind, bind*)
  (setq leaf-backend/:bind  nil
        leaf-backend/:bind* nil)
#+END_SRC

~leaf.el~ provide ~bind-key.el~ backend,
but it's easy to create other package manager's backend.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-bind
    (match-expansion-let ((leaf-backend/:bind 'bind-key))
      (leaf foo
        :bind (("M-s O" . moccur)
               :map isearch-mode-map
               ("M-o" . isearch-moccur)
               ("M-O" . isearch-moccur-all))
        :init
        (setq isearch-lazy-highlight t)
        :config
        (leaf moccur-edit))
      '(progn
         (progn
           (setq isearch-lazy-highlight t))
         (progn
           (require 'foo)
           (funcall #'leaf-backend/:bind-bind-key 'foo
                    '(("M-s O" . moccur)
                      :map isearch-mode-map
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all)))
           (leaf moccur-edit)))))
#+END_SRC
Of course, setting and requiring of the backend itself must be
completed before using ~:ensure~ keyword.

*** :pre-setq, :setq keyword
:PROPERTIES:
:ID:       D5298BD4-6724-4D3A-932F-50A845F51D96
:END:
~pre-setq~, ~post-setq~ to setq before and after ~require~ package.
#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-pre-setq
    (match-expansion
     (leaf foo
       :pre-setq ((bar . 'baz))
       :init (foo-pre-init)
       :config (foo-post-init))
     '(progn
        (setq bar 'baz)
        (progn
          (progn
            (foo-pre-init))
          (progn
            (require 'foo)
            (foo-post-init))))))

  (cort-deftest leaf-test/:simple-post-setq
    (match-expansion
     (leaf foo
       :setq ((bar . 'baz))
       :init (foo-pre-init)
       :config (foo-post-init))
     '(progn
        (progn
          (foo-pre-init))
        (progn
          (require 'foo)
          (setq bar 'baz)
          (foo-post-init)))))
#+END_SRC

*** :setq-default, :custom keyword
:PROPERTIES:
:ID:       5C7F02BB-1CBF-48A9-916D-9792A2C3815F
:END:
~:setq-default~, ~:custom~ to itself after ~require~ package
#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-post-setq
    (match-expansion
     (leaf foo
       :setq ((bar . 'baz))
       :init (foo-pre-init)
       :config (foo-post-init))
     '(progn
        (progn
          (foo-pre-init))
        (progn
          (require 'foo)
          (setq bar 'baz)
          (foo-post-init)))))

  (cort-deftest leaf-test/:simple-custom-set-variables
    (match-expansion
     (leaf foo
       :custom-set-variables ((bar . 'baz))
       :init (foo-pre-init)
       :config (foo-post-init))
     '(progn
        (progn
          (foo-pre-init))
        (progn
          (require 'foo)
          (custom-set-variables '(bar 'baz))
          (foo-post-init)))))
#+END_SRC

*** :custom-face keyword
:PROPERTIES:
:ID:       F77582D3-F6D8-43E9-98D2-748227AC19B1
:END:
~:custom-face~ keyword define custom-face by ~custom-set-faces~.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-custom-face
    (match-expansion
     (leaf eruby-mode
       :custom-face
       (eruby-standard-face ((t (:slant italic)))))
     '(progn
        (require 'eruby-mode)
        (custom-set-faces
         '(eruby-standard-face
           ((t
             (:slant italic))))))))

  (cort-deftest leaf-test/:simple-multi-custom-face
    (match-expansion
     (leaf eruby-mode
       :custom-face
       (eruby-standard-face ((t (:slant italic))))
       (eruby-standard-face2 ((t (:slant italic)))))
     '(progn
        (require 'eruby-mode)
        (custom-set-faces
         '(eruby-standard-face
           ((t
             (:slant italic)))))
        (custom-set-faces
         '(eruby-standard-face2
           ((t
             (:slant italic))))))))
#+END_SRC

*** :load-path keyword
:PROPERTIES:
:ID:       5EF5D2A6-FDA6-4A57-873D-1E2A63EFD0BC
:END:
~:load-path~ keyword add loadpath located on ~user-setting-directory~.

#+BEGIN_SRC emacs-lisp
  (match-expansion
   (leaf ivy
     :load-path "site-lisp/swiper" "site-lisp/ivy")
   '(progn
      (leaf-list-add-to-list 'load-path
                             ("~/.emacs.d/local/26.1/site-lisp/swiper"
                              "~/.emacs.d/local/26.1/site-lisp/ivy"))
      (progn
        (require 'ivy))))

  (match-expansion
   (leaf ivy
     :load-path "site-lisp/swiper")
   '(progn
      (leaf-list-add-to-list 'load-path
                             ("~/.emacs.d/local/26.1/site-lisp/swiper"))
      (progn
        (require 'ivy))))
#+END_SRC
*** :config keyword
:PROPERTIES:
:ID:       390B5A74-6FD1-45AF-809B-AF8ACD35D40D
:END:
~:config~ keyword expect sexp will evaluated after ~require~ package.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-config
    (match-expansion
     (leaf foo :config (setq bar 'baz))
     '(progn
        (require 'foo)
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-init-config
    (match-expansion
     (leaf foo :require foo-hoge foo-piyo
           :init
           (setq bar1 'baz)
           (setq bar2 'baz)
           :config
           (setq bar3 'baz)
           (setq bar4 'baz))
     '(progn
        (progn
          (setq bar1 'baz)
          (setq bar2 'baz))
        (progn
          (require foo-hoge)
          (require foo-piyo)
          (setq bar3 'baz)
          (setq bar4 'baz)))))
#+END_SRC
** Condition keywords
:PROPERTIES:
:ID:       601B40F8-E41C-4DF2-94E0-22059D2F0AEE
:END:
*** :disabled keyword
:PROPERTIES:
:ID:       FB78E91B-A83E-4435-98A5-06A88BD2B58D
:END:
~:disabled~ keyword expect boolean.

If you put ~:disabled t~ keyword, that ~leaf~ block just converting to nil.

Ignore the specification of ~:disabled~ by setting ~t~ to ~nil~.

~:disabled~ will adopt the value of value declared first.
#+begin_src emacs-lisp
  ;; simple :disabled t pattern
  ;; :disabled t => disable block (convert to just nil)
  (cort-deftest leaf-test:/simple-disabled-t
    (match-expansion
     (leaf foo :disabled t)
     'nil))

  ;; simple :disabled nil pattern
  ;; :disabled nil => ignore :disabled
  (cort-deftest leaf-test:/simple-disabled-nil
    (match-expansion
     (leaf foo :disabled nil)
     '(progn
        (require 'foo))))

  ;; multiple :disabled value is ok, adoped first value.
  ;; :disabled t nil => :disabled t => disable block
  (cort-deftest leaf-test:/disabled-4-
    (match-expansion
     (leaf foo :disabled t nil :config (message "bar"))
     'nil))

  ;; multiple :disabled keyword is ok, adoped first value.
  ;; :disabled nil t t => :disabled nil => ignore :disabled
  (cort-deftest leaf-test:/disabled-5+
    (match-expansion
     (leaf foo :disabled nil t :config (message "bar") :disabled t)
     '(progn
        (require 'foo)
        (message "bar"))))

  ;; :disabled keyword value allowed functions and macros returns boolean value.
  ;; :disable (rt) (rnil) (rt) => :disable t nil t => :disable t
  (cort-deftest leaf-test:/disabled-5++
    (match-expansion
     (leaf foo :disabled (rnil) (rt) :config (message "bar") :disabled (rt))
     '(progn
        (require 'foo)
        (message "bar"))))
#+end_src

*** :if, :when, :unless keyword
:PROPERTIES:
:ID:       19A9FBE7-3F00-4CDF-A3DA-73B7140EC566
:END:
~:if~, ~:when~, ~:unless~ keywords expect sexp return boolean or just boolean value
and wrap converted sexp specified function.

If specified multiple those keywords, evaluate sexp in ~and~.
#+begin_src emacs-lisp
  ;; simple :if pattern
  (cort-deftest leaf-test:/simple-if
    (match-expansion
     (leaf foo :if t)
     '(if t
          (progn
            (progn
              (require 'foo))))))

  ;; simple :when pattern
  (cort-deftest leaf-test/:simple-when
    (match-expansion
     (leaf foo :when t)
     '(when t
         (progn
           (require 'foo)))))

  ;; simple :unless pattern
  (cort-deftest leaf-test/:simple-unless
    (match-expansion
     (leaf foo :unless t)
     '(unless t
         (progn
           (require 'foo)))))

  ;; multiple :if pattern
  (cort-deftest leaf-test/:simple-multi-if
    (match-expansion
     (leaf foo :if (rt) :if (rnil) (mt))
     '(if (and (rt) (rnil) (mt))
          (progn
            (progn
              (require 'foo))))))

  ;; multiple condition pattern
  ;; sorted in the order :if, :when, :unless and merge.
  (cort-deftest leaf-test/:simple-multi-conds
    (match-expansion
     (leaf foo :if (rt) :when (rnil) (mt) :unless (rt) :if (rnil))
     '(if (and (rt) (rnil))
          (progn
            (when (and (rnil) (mt))
              (unless (rt)
                (progn
                  (require 'foo))))))))

  ;; if you want to evaluate sexp in `or', just specify that sexp.
  (cort-deftest leaf-test/:if-2
    (match-expansion
     (leaf foo :if (or (rt) (rnil)))
     '(if (or (rt) (rnil))
          (progn
            (progn
              (require 'foo))))))
#+end_src

** Byte compile keywords
:PROPERTIES:
:ID:       FCA0C2E6-21C6-475C-AEA7-272649A21CE0
:END:
*** :byte-compile-funcs, :byte-compile-vars keyword
:PROPERTIES:
:ID:       2889E811-A291-47F7-B714-FABE4034D240
:END:
~:byte-compile-funcs~ and ~:byte-compile-vars~ to tell bytecompiler.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-multi-byte-compile-vars
    (match-expansion
     (leaf for
       :byte-compile-vars for-var1 for-var2)
     '(progn
        (eval-when-compile
          (defvar for-var1)
          (defvar for-var2))
        (progn
          (require 'for)))))

  (cort-deftest leaf-test/:simple-multi-byte-compile-funcs
    (match-expansion
     (leaf for
       :byte-compile-funcs ((hoge-fn1 . hoge)
                            (hoge-fn2 . hoge)))
     '(progn
        (eval-when-compile
          (autoload #'hoge-fn1 "hoge" nil t)
          (autoload #'hoge-fn2 "hoge" nil t))
        (progn
          (require 'for)))))
#+END_SRC

** Documentation keywords
:PROPERTIES:
:ID:       AEB3D9C7-C27A-4C0D-B7CA-8E3929A18C46
:END:
~leaf.el~ can describe a document with an affinity grammar.
By default, ~:doc~, ~:file~, ~:url~ keywords are provided.

In fact, these keywords are simply ignored.

#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-doc-keyword
    (match-expansion
     (leaf foo
       :doc "this package is awesome!!"
       :require nil
       :config (setq bar 'baz))
     '(progn
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-doc-keywords
    (match-expansion
     (leaf foo
       :doc "this package is awesome!!"
       :file "~/path/to/package/file.el"
       :url "https://www.example.com/"
       :require nil
       :config (setq bar 'baz))
     '(progn
        (setq bar 'baz))))
#+END_SRC

I think that you can use various ways of using such as
describing the URL you referred to, writing a brief description of the package,
writing a file path for FFAP.

If you want other keywords, you can easily add them. (see source)
#+BEGIN_SRC emacs-lisp
  ;; top-level operation, but don't do anything when don't need it.
  ;; (eg when loading multiple times)
  (mapc (lambda (x)
          (unless (memq x leaf-keywords)
            (leaf-add-doc-keyword x)))
        (reverse '(:doc :file :url)))
#+END_SRC

* Developer information
:PROPERTIES:
:ID:       091E1E16-C805-4EFC-B3DF-8CFFEF262016
:END:
~leaf.el~ creates the intended elisp code from DSL with a simple mechanism.

It is clear what internal conversion is done and it is also easy to customize it.
** leaf.el mechanism
:PROPERTIES:
:ID:       ECE81F64-86A4-41E2-921B-7BC8C0088C04
:END:
*** ~leaf (name &rest args)~ macro
:PROPERTIES:
:ID:       BC5DC943-58E0-40DC-9CF5-43521E990E7C
:END:
This is ~leaf.el~ frontend macro. Users use only this macro.

Process.
1. Pass arguments to ~leaf-core~.

*** ~leaf-core (name args)~ function
:PROPERTIES:
:ID:       95158ACD-2622-4DC4-804D-366CC1DE240C
:END:
This is the core process for leaf macro expansion.

Process.
1. ~leaf-append-defaults~ to append default value (~leaf-defaults~) to ARGS
2. ~leaf-normalize-plist~ to normalize pseudo-plist, ARGS
3. ~leaf-sort-values-plist~ to sort ARGS
4. pass NAME and ARGS to ~leaf-process-keywords~

**** ~leaf-append-defaults (plist)~ function
:PROPERTIES:
:ID:       6A42C4A3-DD34-45A8-9D6D-D51985000CAC
:END:
Append leaf default values to PLIST.
See ~leaf-defaults~. You can customize this value.

EXAMPLE:
#+BEGIN_SRC emacs-lisp
  (leaf-append-defaults nil)
  -> (:init nil :require t)

  (leaf-append-defaults '(:require foo))
  -> (:require foo :init nil :require t)
#+END_SRC

**** ~leaf-normalize-plist (plsit mergep)~ function
:PROPERTIES:
:ID:       ADCDCD51-44E1-4D1B-AE7F-EA04743EFD25
:END:
Given a pseudo-PLIST, return PLIST,
if MERGEP is t, return well-formed PLIST.

MERGEP every ~t~ in leaf.

EXAMPLE:
#+BEGIN_SRC emacs-lisp
  (leaf-normalize-plist
    '(:defer t
      :config (message "a") (message "b")
      :config (message "c")) nil)
   -> (:defer (t)
       :config ((message "a") (message "b"))
       :config ((message "c")))

  (leaf-normalize-plist
    '(:defer t
      :config (message "a") (message "b")
      :config (message "c")) t)
   -> (:defer (t)
       :config ((message "a") (message "b") (message "c"))
#+END_SRC

**** ~leaf-sort-values-plist (plist)~ function
:PROPERTIES:
:ID:       A875F061-194B-4CAC-B124-923533DC6529
:END:
Given a list-valued PLIST, return sorted-list PLIST by order ~leaf-keywords~.

EXAMPLE:
(leaf-sort-values-plist
  '(:config (message "a")
    :disabled (t)))
 -> (:disabled (t)
     :config (message "a"))

*** ~leaf-pcocess-keywords (name plist)~ function
:PROPERTIES:
:ID:       F4C1ECC9-1004-471F-8C82-BB33A21A0863
:END:
Process keywords for NAME.
The KEY and VALUE are taken from the PLIST and pass to the handler.

The handler is named leaf-handler/KEY.

** Adding custom keyword(s)
:PROPERTIES:
:ID:       7CFD0D29-9E59-4726-B8BC-17A8042075BC
:END:
~leaf.el~ can easily be expanded by adding keywords.

Actually, it is realized by two steps of adding keyword and adding handler.

Example:
#+BEGIN_SRC emacs-lisp
  (cort-deftest leaf-test/:simple-keyword-add
    (match-expansion
     (leaf foo
       :require h s :message-post-require "foo!" :config (setq bar 'baz))
     '(progn
        (require h)
        (require s)
        (message "foo!")
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-keyword-add-2
    (match-expansion
     (leaf foo
       :require h s
       :message-post-require "foo!"
       :config (setq bar 'baz)
       :message-post-require "post!"
       :message-pre-require "pre")
     '(progn
        (message "pre")
        (require h)
        (require s)
        (message "foo!")
        (message "post!")
        (setq bar 'baz))))

  (cort-deftest leaf-test/:simple-keyword-list-add
    (match-expansion
     (leaf foo
       :require h s
       :tmp-pre (message "start tmp")
       :tmp-post (setq foo 'bar)
       :tmp-pre (message "really start tmp!"))
     '(progn
        (require h)
        (require s)
        (message "start tmp")
        (message "really start tmp!")
        (setq foo 'bar))))
#+END_SRC

*** Add keyword(s)
:PROPERTIES:
:ID:       1C8BA8F9-AF24-490B-9E36-8D0985014D12
:END:
The keyword has an appropriate place in ~leaf-keywords~.

Because the keywords are sorted in order of ~leaf-keywords~,
and they are processed and expanded in that order.

You can use these functions to add keyword(s)
- ~leaf-add-keyword-before (target belm)~
- ~leaf-add-keyword-after (target aelm)~
- ~leaf-add-keyword-list-before (targetlst belm)~
- ~leaf-add-keyword-list-after (targetlst aelm)~

If you message before ~require~, you should use
~(leaf-add-keyword-before :message-pre-require :require)~.

Or if you message after ~require~, you should use
~(leaf-add-keyword-after :message-post-require :require)~.

You can add keywords like,
~(leaf-add-keyword-list-after '(:tmp-pre :tmp-post) :config)~

*** Define handler
:PROPERTIES:
:ID:       F2358E14-FC68-4E06-9B19-781C0A8B7766
:END:
Then, you should define a handler for new keyword(s) each.

NOTE: Since VALUE is a list, be careful when implementing a handler.
#+BEGIN_SRC emacs-lisp
  (defun leaf-handler/:message-pre-require (name value rest)
    "process :message-pre-require."
    (let ((body (leaf-process-keywords name rest)))
      `(,@(mapcar (lambda (x) `(message ,x)) value) ,@body)))

  (defun leaf-handler/:message-post-require (name value rest)
    "process :message-post-require."
    (let ((body (leaf-process-keywords name rest)))
      `(,@(mapcar (lambda (x) `(message ,x)) value) ,@body)))

  (defun leaf-handler/:tmp-pre (name value rest)
    "process :tmp-pre."
    (let ((body (leaf-process-keywords name rest)))
      `(,@value ,@body)))

  (defun leaf-handler/:tmp-post (name value rest)
    "process :tmp-post."
    (let ((body (leaf-process-keywords name rest)))
      `(,@value ,@body)))
#+END_SRC
* Why We support Emacs-22?
:PROPERTIES:
:ID:       773EEC5D-AE59-4BD9-ABC9-BE3540BAD0DC
:END:
Bundling Emacs-22.1 on macOS 10.13 (High Sierra), we support this.

* Welcome PR
:PROPERTIES:
:ID:       472A6387-7B54-4ED4-8C39-21E291C7D990
:END:
We welcome PR!
Travis Cl test ~leaf-test.el~ with all Emacs version 23 or above.

I think that it is difficult to prepare the environment locally, 
so I think that it is good to throw PR and test Travis for the time being!
Feel free throw PR!

* Special Thanks
:PROPERTIES:
:ID:       16502214-F943-4A31-ABB4-217AC14FCE53
:END:
Advice and comments given by [[http://emacs-jp.github.io/][Emacs-JP]]'s forum member has been a great help
in developing ~leaf.el~.

Thank you very much!!
